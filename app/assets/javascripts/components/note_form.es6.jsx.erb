class NoteForm extends React.Component {
  constructor(props, context) {
    super(props, context);

    this.state = {
      note: this.props.note
    };

    this.shouldRerender = true;
  }

  render() {
    return (
      <form className="simple_form form-horizontal" onSubmit={this.handleFormSubmit}>
        <div className="form-inputs">
          <div className="form-group form-group-no-label string optional note_title">
            <input
              type="text"
              className="string optional form-control"
              value={this.state.note.title}
              onChange={this.handleTitleChange.bind(this)}
              placeholder="Title"
              ref={(c) => this.$title = $(c)}
            />
          </div>
          <div className="form-group form-group-no-label text optional note_content">
            <div
              dangerouslySetInnerHTML={ { __html: this.state.note.content }}
              ref={(c) => this.$content = $(c)}
            ></div>
          </div>
        </div>
      </form>
    );
  }

  // prevent form submission by hitting enter.
  // changes will be asynchronously saved by ajax.
  handleFormSubmit(e) {
    e.preventDefault();
    return false;
  }

  handleTitleChange(e) {
    this.shouldRerender = true;
    this.state.note.title = e.target.value;
    this.setState({ note: this.state.note }, this.handleChange);
  }

  handleContentChange(e) {
    this.shouldRerender = false;
    this.state.note.content = this.$content.html();
    this.setState({ note: this.state.note }, this.handleChange);
  }

  handleChange() {
    this.props.handleChange(this.state.note);
  }

  componentDidMount() {
    this.focusTitleFieldIfNewNote();
    this.renderEditor();
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps.note.uid !== this.state.note.uid) {
      // a different note is shown.
      this.shouldRerender = true;
      this.setState({
        note: nextProps.note
      }, () => {
        this.focusTitleFieldIfNewNote();

        // FIXME: not sure why this is needed. for the two cases everything is
        // ok:
        // 1. an existing note is shown
        // 2. a new note is shown
        // only when a new note after creating a new note is created, the
        // content stays at the previous content value. setting it here
        // explicitely fixes this.
        if (this.state.note.isNew()) {
          this.$content.html(this.state.note.content);
        }
      });
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    // don't rerender if the RTE content changes. the cursor jumps to the
    // beginning of the content if we re-initialize the RTE content.
    return this.shouldRerender;
  }

  renderEditor() {
    $.trumbowyg.svgPath = '<%= asset_path('trumbowyg/dist/ui/icons.svg') %>';

    this.$content
      .trumbowyg({
        btns: [
          ['formatting'],
          'btnGrp-semantic',
          'btnGrp-lists',
          ['link'],
          ['removeformat'],
          ['fullscreen']
        ],
        autogrow: true
      })
      .on('tbwchange', this.handleContentChange.bind(this))
      .on('tbwpaste', this.handleContentChange.bind(this));
  }

  focusTitleFieldIfNewNote() {
    if (this.state.note.isNew()) {
      this.$title.focus();
    }
  }
}
